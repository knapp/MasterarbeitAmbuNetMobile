\chapter{Basisanwendung und Plug-Ins zur Realisierung der identifizierten Anforderungen}
\label{ch:pluginarchitektur}

[Vorgeplänkel Kapitel]

\section{Aufgaben und Struktur der Basisanwendung}

Um einem Benutzer von \app die Bedienung der Anwendung zu erleichtern, sollte ein einheitliches Gesamterscheinungsbild
eingehalten werden, da ständige Strukturwechsel in der grafischen Oberfläche zu Unübersichtlichkeit führen können
\textcolor{red}{[Quelle]}. Hierzu wurde die in Abbildung \ref{fig:gui} gezeigte feste Struktur der grafischen Oberfläche
entworfen. Oben links befindet sich das Logo der Anwendung, darunter ist ein Bereich für die Darstellung von
Informationen wie das aktuell verwendete Plug-In oder der gerade behandelte Klient reserviert. Am oberen Rand rechts des
Logos wurde eine Leiste zum Platzieren von Buttons zur Navigation eingefügt. Der größte Bereich ist zur Darstellung und
Bearbeitung des eigentlichen Inhalts gedacht.\\

\begin{figure}
	\centering
	\includegraphics[scale=0.4]{figures/GUICareNetMobile.pdf}
	\caption{Struktur der grafischen Oberfläche von \app}
	\label{fig:gui}
\end{figure}

Die Strukturierung und Gestaltung der grafischen Darstellung erfolgt mittels HTML5 und CSS3, die Funktionalität wird
mittels JavaScript entwickelt. Gegenüber der Entwicklung einer nativen Anwendung für Android ergeben sich bei der
Entwicklung mit JavaScript gewisse Schwierigkeiten. Während Java eine objektorientierte Sprache ist, bei der
Typsicherheit und Kapselung von Funktionalität in Klassen zu den Eigenschaften gehören, ist JavaScript eine
Scriptsprache, die keinerlei Typsicherheit und nur bedingte Kapselungsmöglichkeiten bietet. Ein wichtiger Unterschied
ist, dass Java vor der Ausführung zunächst kompiliert, d.h. in eine maschinenverständliche Zwischensprache übersetzt
werden muss, während JavaScript direkt vom Browser interpretiert werden kann. Dies impliziert, dass JavaScript-Code,
selbst wenn er bereits auf einer Webseite ausgeführt wird, dem Nutzer im Klartext zur Verfügung steht, während der
Java-Code nur bedingt und durch aufwendige Verfahren wieder dekompiliert und somit im Klartext verfügbar gemacht werden
kann. Dieser Eigenschaft muss sich ein Entwickler besonders im Bezug auf im Quellcode vermerkte sicherheitsrelevante
Informationen bewusst sein.\\
Während der Entwicklung kann vor allem die fehlende Möglichkeit der Kapselung problematisch werden. Abbildung
\ref{fig:vergleichJavaJS} zeigt Beispielimplementierungen in Java und JavaScript. Links wurde eine Klasse erstellt, die
Methoden und Variablen kapselt. Wird eine Variable außerhalb einer Methode definiert (Abbildung
\ref{fig:vergleichJavaJS}: \textit{ersteVariableJava}, ist diese in der gesamten Klasse verfügbar. Ist die Variable
als \textit{public} gekennzeichnet, kann auf sie über \textit{Klassenname.variablenName} zugegriffen werden.
Wird sie als \textit{private} deklariert, ist sie nur innerhalb der Klasse verfügbar. Das gleiche gilt für Methoden.
Wird eine Variable innerhalb einer Methode definiert (Abbildung \ref{fig:vergleichJavaJS}: \textit{zweiteVariable}),
kann auch nur innerhalb dieser Methode auf die Variable zugegriffen werden.\\
In JavaScript sind grundsätzlich alle Methoden global verfügbar. Die Verfügbarkeit beschränkt sich hier nicht auf eine
Klasse oder Datei, sondern auf eine einmal deklarierte Methode kann von allen anderen JavaScript- und HTML-Dateien, die
gleichzeitig mit dieser Datei vom Browser geladen wurden, zugegriffen werden. Eine Klassendefinition kann nur in sofern
erfolgen, dass einem Methodennamen der Name einer anderen vorher definierten Methode vorangestellt wird (Abbildung
\ref{fig:vergleichJavaJS}: \textit{beispiel.methodeJS()}). Hiermit wird es möglich, einen Namensraum zu definieren,
um Methoden einem bestimmten Kontext (hier: \textit{beispiel}) zuzuordnen. Wird nun aber an irgend einer anderen Stelle
im Kontext der geladenen HTML- und JavaScript-Dateien der Name der Methode verwendet, kann der Interpreter, der Browser,
keine eindeutige Zuordnung des Namens zu ausführbarem Quellcode mehr herstellen und es wird nichts ausgeführt.\\
Ebenso verhält es sich mit Variablen. Wird eine Variable mit dem Zusatz \textit{var} außerhalb einer Methode definiert,
ist sie global verfügbar. Das gleiche gilt, wenn eine Variable ganz ohne Zusatz (Abbildung
\ref{fig:vergleichJavaJS}: \textit{zweiteVariableJS}) definiert wird. Nur wenn eine Variable innerhalb einer Methode mit
dem Zusatz \textit{var} erstellt wird, kann sie nur innerhalb der Methode verwendet werden. Dieser Umstand kann zu
massiven Problemen führen. Vergisst ein Entwickler beispielsweise nur ein einziges Mal den Zusatz \textit{var} bei der
Definition einer Laufvariable in einer Schleife (häufig mit dem Namen \textit{i}), wird diese nun global geltende
Variable alle anderen Schleifen, die ebenfalls die Laufvariable \textit{i} verwenden, beeinflussen. Da dies kein
syntaktischer, sondern ein semantischer Fehler ist, kann dieser nicht von automatisierten Fehlerfindungswerkzeugen
entdeckt werden und es beginnt die Suche nach der Nadel im Heuhaufen. Derartige Umstände können sehr viel Zeit kosten.\\

 

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figures/VergleichJavaJavaScript.pdf}
	\caption{Vergleich zweier Beispielimplementierungen von Java und JavaScript}
	\label{fig:vergleichJavaJS}
\end{figure} 

Wie in Kapitel \ref{sec:entwurfsentscheidungen} beschrieben, wird \app auf Basis einer Plug-In-Architektur entworfen.
Abbildung \ref{fig:archikonzept} zeigt das grundsätzliche Konzept. Die Basisanwendung bietet wichtige
Grundfunktionalitäten wie einen Log-In, Methoden zur sicheren Kommunikation mit CareNet, Methoden zur Verwaltung lokaler
Datenbanken sowie eine Koordination der Plug-Ins. Die eigentliche Funktionalität, um mit \app arbeiten zu können, wird
ausschließlich über Plug-Ins hinzugefügt. Diese werden über eine vordefinierte Schnittstelle, in Abbildung
\ref{fig:archikonzept} dargestellt als Ring, hinzugefügt. 

\begin{figure}
	\centering
	\includegraphics[scale=0.75]{figures/ArchitekturCareNetmobileAusarb.pdf}
	\caption{Architekturkonzept \app }
	\label{fig:archikonzept}
\end{figure}





\begin{itemize}
  \item Grundsätzlich: Plug-In-Architektur angelehnt an Eclipse-Bsp [CHECK]
  \item Bestandteile: Grundanwendung (Basis), Plug-Ins [CHECK]
  \item Aufgaben Grundanwendung: Sicherheit (Login, Kommunikation), Verwaltung von Plug-Ins, Bereitstellen einer
  GUI-Struktur, zentrale Verwaltung lokaler Datenbanken (Methoden) [CHECK]
  \item Programmiereigenschaften von JavaScrip ggü. Java
  \item Plug-Ins sollten keinen Einfluss auf Grundanwendung haben (Kapselung, aber komplette Trennung nicht möglich)
  \item unbegrenzte Anzahl an Plug-Ins
  \item Konfiguration eingebundener Plug-Ins (JSON)
  \item Grafik Gesamtarchitektur
  \item Grundstruktur: jQuery mobile (Seitenaufbau, alles mit Divs, CSS, wie Webseite)
  \item Login
	  \begin{itemize}
	    \item als Dialog (vorgeschaltete Seite)
	    \item Mandant, Nutzername, PW
	    \item Wg. REST-Prinzip: Nur einmalige Überprüfung, ob Daten korrekt sind, kein Aufbau einer dauerhaften Verbindung
	    \item Speicherung der Daten im lokalen Speicher im Klartext (HTML5/PhoneGap Key-Value-Speicher)
	    \item Senden der Daten bei jeder Anfrage (Beispielanfrage)
	    \item Authentifizierungstring: mandant/nutzername:passwort
	    \item Middleware verschlüsselt String mit Base64 und sendet den an CareNet (kann einfach entschlüsselt werden)
	    \item Daten werden so unverschlüsselt gesendet, d.h. Verbindung an sich muss gesichert werden (https)
	    \item Bei Logout werden Daten einfach aus lokalem Speicher gelöscht
	    \item Sicherheitsproblem bei eingeschleuster Spyware (JS) über Browser? Nein, wg. Unabhängigkeit von
	    PhoneGap-Browser/WebView und installierten anderen Browsern
	  \end{itemize}
  \item Struktur GUI
\end{itemize}

\ldots

\section{Einbinden von Plug-Ins in die Basisanwendung}
\ldots

\begin{itemize}
  \item Plug-Struktur:
	  \begin{itemize}
	    \item Namenskonventionen wg. JS global
	    \item Alle zugehörigen Dateien gekapselt in einem Ordner
	    \item Icon
	    \item JS-Datei (Problem der dynamischen Einbingung)
	    \item CSS-Datei
	    \item Versionsnummer, Konfig-Datei (Abhängigkeiten inkl. Versionsnummern)
	    \item Konstruktor, Methode zur Initialisierung
	    \item Arbeit mir Cotainern für GUI
	    \item Beschreibung der Abhängigkeiten zu Bibliotheken wie jQuery, jQuery mobile, PhoneGap (Redundanzen vermeiden)
	    \item Grafik zu Plug-In-Strukur
	  \end{itemize}
  \item Namenskonventionen
  \item Vorgang des Einbindens
  \item Probleme, Erweiterungsmöglichkeiten
\end{itemize}

\section{Das Plug-In "`Kontakte"'}
Für alle Plug-Ins feste Beschreibungsstruktur:
\begin{itemize}
  \item Begründung für Plug-In (aus welchen Anforderungen geht Plug-In hervor)
  \item Aufbau/Navigationsstruktur
  \item Zentrale Frage, die beantwortet werden muss: Welche Funktionalität geht aus welcher
  Anforderung hervor?
\end{itemize}

\ldots

\section{Das Plug-In "`Touren"'}
\ldots

\section{Das Plug-In "`Hilfe"'}
\ldots