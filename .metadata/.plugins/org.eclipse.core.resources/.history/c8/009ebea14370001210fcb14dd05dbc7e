\chapter{Basisanwendung und Plug-Ins zur Realisierung der identifizierten Anforderungen}
\label{ch:pluginarchitektur}

[Vorgeplänkel Kapitel]

\section{Aufgaben und Struktur der Basisanwendung}

Um einem Benutzer von \app die Bedienung der Anwendung zu erleichtern, sollte ein einheitliches Gesamterscheinungsbild
eingehalten werden, da ständige Strukturwechsel in der grafischen Oberfläche zu Unübersichtlichkeit führen können
\textcolor{red}{[Quelle]}. Hierzu wurde die in Abbildung \ref{fig:gui} gezeigte feste Struktur der grafischen Oberfläche
entworfen. Oben links befindet sich das Logo der Anwendung, darunter ist ein Bereich für die Darstellung von
Informationen wie das aktuell verwendete Plug-In oder der gerade behandelte Klient reserviert. Am oberen Rand, rechts
des Logos, wurde eine Leiste zum Platzieren von Buttons zur Navigation eingefügt. Der größte Bereich ist zur Darstellung
und Bearbeitung des eigentlichen Inhalts gedacht.\\

\begin{figure}
	\centering
	\includegraphics[scale=0.4]{figures/GUICareNetMobile.pdf}
	\caption{Struktur der grafischen Oberfläche von \app}
	\label{fig:gui}
\end{figure}

Die Strukturierung und Gestaltung der grafischen Oberfläche erfolgt mittels HTML5 und CSS3, die Funktionalität wird
mit JavaScript entwickelt. Gegenüber der Entwicklung einer nativen Anwendung für Android ergeben sich bei der
Entwicklung mit JavaScript gewisse Schwierigkeiten. Während Java eine objektorientierte Sprache ist, bei der
Typsicherheit und Kapselung von Funktionalität in Klassen zu den Eigenschaften gehören, ist JavaScript eine
Scriptsprache, die keinerlei Typsicherheit und nur bedingte Kapselungsmöglichkeiten bietet. Ein wichtiger Unterschied
ist, dass Java vor der Ausführung zunächst kompiliert, d.h. in eine maschinenverständliche Zwischensprache übersetzt
werden muss, während JavaScript direkt vom Browser interpretiert werden kann. Dies impliziert, dass JavaScript-Code,
selbst wenn er bereits auf einer Webseite ausgeführt wird, dem Nutzer im Klartext zur Verfügung steht, während der
Java-Code nur bedingt und durch aufwendige Verfahren wieder dekompiliert und somit im Klartext verfügbar gemacht werden
kann. Dieser Eigenschaft muss sich ein Entwickler besonders im Bezug auf im Quellcode vermerkte sicherheitsrelevante
Informationen bewusst sein.\\
Während der Entwicklung kann vor allem die fehlende Möglichkeit der Kapselung problematisch werden. Abbildung
\ref{fig:vergleichJavaJS} zeigt Beispielimplementierungen in Java und JavaScript. Links wurde eine Klasse erstellt, die
Methoden und Variablen kapselt. Wird eine Variable außerhalb einer Methode definiert (Abbildung
\ref{fig:vergleichJavaJS}: \textit{ersteVariableJava}), ist diese in der gesamten Klasse verfügbar. Ist die Variable
als \textit{public} gekennzeichnet, kann auf sie über \textit{Klassenname.variablenName} zugegriffen werden.
Wird sie als \textit{private} deklariert, ist sie nur innerhalb der Klasse verfügbar. Das gleiche gilt für Methoden.
Wird eine Variable innerhalb einer Methode definiert (Abbildung \ref{fig:vergleichJavaJS}: \textit{zweiteVariable}),
kann auch nur innerhalb dieser Methode auf die Variable zugegriffen werden.\\

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figures/VergleichJavaJavaScript.pdf}
	\caption{Vergleich zweier Beispielimplementierungen von Java und JavaScript}
	\label{fig:vergleichJavaJS}
\end{figure}

In JavaScript sind grundsätzlich alle Methoden global verfügbar. Die Verfügbarkeit beschränkt sich hier nicht auf eine
Klasse oder Datei, sondern auf eine einmal deklarierte Methode kann von allen anderen JavaScript- und HTML-Dateien, die
gleichzeitig mit dieser Datei vom Browser geladen wurden, zugegriffen werden. Eine Klassendefinition kann nur in sofern
erfolgen, dass einem Methodennamen der Name einer anderen vorher definierten Methode vorangestellt wird (Abbildung
\ref{fig:vergleichJavaJS}: \textit{beispiel.methodeJS()}). Hiermit wird es möglich, einen Namensraum zu definieren,
um Methoden einem bestimmten Kontext (hier: \textit{beispiel}) zuzuordnen. Wird allerdings an anderer Stelle im
geladenen JavaScript-Code die selbe Kontext-Methodennamen-Kombination verwendet, kann der Interpreter, der Browser,
keine eindeutige Zuordnung des Namens zu ausführbarem Quellcode mehr herstellen und es wird nichts ausgeführt.\\
Ebenso verhält es sich mit Variablen. Wird eine Variable mit dem Zusatz \textit{var} außerhalb einer Methode definiert,
ist sie global verfügbar. Das gleiche gilt, wenn eine Variable ganz ohne Zusatz (Abbildung
\ref{fig:vergleichJavaJS}: \textit{zweiteVariableJS}) definiert wird. Nur wenn eine Variable innerhalb einer Methode mit
dem Zusatz \textit{var} erstellt wird, kann sie nur innerhalb der Methode verwendet werden. Dieser Umstand kann zu
massiven Problemen führen. Vergisst ein Entwickler beispielsweise nur ein einziges Mal den Zusatz \textit{var} bei der
Definition einer Laufvariable in einer Schleife (häufig mit dem Namen \textit{i}), wird diese nun global geltende
Variable alle anderen Schleifen, die ebenfalls die Laufvariable \textit{i} verwenden, beeinflussen. Da dies kein
syntaktischer, sondern ein semantischer Fehler ist, kann dieser nicht von automatisierten Fehlerfindungswerkzeugen
entdeckt werden und es beginnt die sprichwörtliche Suche nach der Nadel im Heuhaufen. Derartige Umstände können sehr
viel Zeit kosten.\\

Einzelne Plug-Ins sollen die in Abbildung \ref{fig:gui} gezeigte Struktur nutzen, um Inhalte darzustellen. Damit dies
möglich ist, müssen die einzelnen Bereiche, welche als HTML-DIV-Elemente erstellt wurden, eindeutig durch \acs{id}s
gekennzeichnet werden. Da es in JavaScript nicht, wie in Java, möglich ist, Konstanten zu definieren, wurden in einer
separaten JavaScript-Datei \textit{CONSTANTS.js} alle \acs{id}s in Form von Variablen hinterlegt, welche den
DIV-Elementen zugewiesen wurden. Der Nachteil von Variablen ist, dass diese während der Laufzeit aus den Plug-Ins heraus
verändert werden können. Aus diesem Grund muss die Konvention eingehalten werden, zentral definierte Variablen nicht zu
verändern, da dies Auswirkungen auf andere Plug-Ins haben könnte. Die Eigenschaft einer Plug-In-Architektur, dass
Plug-Ins keinen Einfluss auf die Basisanwendung haben, kann somit nicht vollständig in JavaScript umgesetzt werden.
Menschliche Fehler durch Nicht-Einhaltung der Konvention bleiben möglich.\\
Der Vorteil von zentral definierten Variablen ist, dass an einer zentralen, übersichtlichen Stelle nachgeschaut werden
kann, wie eine \acs{id} lautet, und dass die wichtigen Strukturelemente für Informationen, Navigation und Inhalt zentral
referenziert werden können. Die Datei \textit{CONSTANTS.js} wird außerdem dazu genutzt, um alle sonstigen in der
Implementierung verwendeten Zeichenketten als Variablen zu hinterlegen. Hierzu zählt beispielsweise die Server-Adresse
der Middleware oder alle Arten von Meldungen an einen Nutzer. Dieses Verfahren erhöht die Wartbarkeit der Anwendung, da
Änderungen an mehrfach verwendeten Zeichenketten nicht \textit{mehrfach} umgesetzt werden müssen, sondern lediglich
\textit{einmal} in der zentralen Datei. Die Wahrscheinlichkeit für Fehler durch nicht vollständig umgesetzte
Anpassungen kann so verringert werden. Dieses Vorgehen ist angelehnt an die zentrale Verwaltung von \textit{String
Ressources} bei der Entwicklung nativer Android-Anwendungen \cite{androidStringRessources}.\\

Eine Grundfunktion, welche die Basisanwendung zur Verfügung stellt, ist ein Log-In zur Sicherung der persönlichen Daten
und einer Identifizierung des Nutzers. Da \app eine mobile Erweiterung von CareNet darstellt, werden keine gesonderten
Konten für die Nutzung der mobilen Anwendung angelegt, sondern es werden die schon existierenden Konten in CareNet
verwendet. Eine Möglichkeit wäre, alle relevanten Daten für einen Log-In aller möglichen Nutzer auf dem Endgerät zu
speichern und einen lokalen Abgleich zu machen, jedoch könnte hierdurch ein Sicherheitsproblem entstehen. Aus diesem
Grund wird bei einem Log-In eine Anfrage an CareNet gesendet, ob die eingegebenen Daten korrekt sind. Benötigt werden
beim Login der Mandant, der Benutzername und das Passwort. Der Log-In erfolgt in der mobilen Anwendung über ein
separates Fenster (eigenständige HTML-Datei) in Form eines Dialogs. Erst wenn von CareNet eine Bestätigung der
Log-In-Daten erhalten wurde, wird die entsprechende HTML-Datei zur Anzeige von Inhalten geladen. Dies verhindert, dass
durch eventuelle Anzeigefehler einem noch nicht authentifizierten Nutzer sensible Daten angezeigt werden, die schon
im Hintergrund bereitliegen.\\

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figures/AuthentifizierungCareCMviaREST.pdf}
	\caption{Überprüfung der Benutzerdaten in \app }
	\label{fig:login}
\end{figure}

In Kapitel \ref{sec:entwurfsentscheidungen} wurde die Kommunikation von \app mit CareNet via \acs{rest} erklärt. Aus
dieser Kommunikation resultiert eine Besonderheit bei der Authentifizierung eines Nutzers mit einem zentralen System.
Abbildung \ref{fig:login} zeigt die notwendigen Schritte zur Authentifizierung eines Nutzers und dem anschließenden
Senden einer Anfrage. Da keine Sitzung aufgebaut werden kann, in der ein Nutzer dauerhaft angemeldet wird, müssen
die kompletten Nutzerdaten bei jeder Anfrage mitgesendet werden.\\
Meldet sich ein Nutzer in \app an, so werden zunächst nur die eingegebenen Daten an CareNet gesendet. Als Antwort kommt
entweder der HTML-Code 200 (\textit{OK}) oder 401 (\textit{Unauthorized}). Sind die Daten korrekt (Code = 200), werden
sie im lokalen Speicher der Anwendung abgelegt, um sie für spätere Anfragen an CareNet nicht noch einmal eingeben zu
müssen. Hierzu kann der von HTML5 angebotene lokale Key-Value-Speicher genutzt werden. In diesem Speicher können
Zeichenketten, referenziert über einen Schlüssel, permanent abgelegt werden und auch nach dem Schließen der hybriden
mobilen Anwendung wieder abgerufen werden. Die Nutzerdaten werden hier allerdings unverschlüsselt abgelegt. Aus
diesem Grund werden die Nutzerdaten aus dem lokalen Speicher gelöscht, sobald sich der Nutzer wieder von
\app abmeldet. Weitere Anfragen an CareNet sind so nicht mehr möglich.\\
In Abbildung \ref{fig:login} wird die Rolle der Middleware vernachlässigt, da diese nicht für das grundsätzliche
Kommunikationsprinzip relevant ist. Tatsächlich übernimmt die Middleware aber einen Arbeitsschritt bei der
Kommunikation. Die Nutzerdaten werden als Zeichenkette \textit{Mandant/Benutzername:Passwort} an die Middleware
übertragen. CareNet benötigt die Daten zur Authentifizierung jedoch in Form einer nach der Base Access Authentication
verschlüsselten Zeichenkette. Base Access Authentication ist \textcolor{red}{[Erlärung Base64 nach Network security:
private communication in a public world, second edition]}. Da PHP standardisierte Methoden zur Erstellung dieser
Verschlüsselung anbietet, wurde entschieden, die Verschlüsselung in die Middleware zu verlagern.\\
Auch wenn es sich bei der Base Access Authentication namentlich um eine Verschlüsselung handelt, ist diese jedoch kein
Schutz gegen einen Zugriff auf die Daten Dritter, da das Verfahren öffentlich bekannt ist. Im Prinzip werden die
Benutzerdaten also im Klartext von \app zu CareNet übertragen. Hört ein Dritter die Kommunikation ab, kann er die
Nutzerdaten auslesen und zweckentfremden. Aus diesem Grund muss die Verbindung an sich verschlüsselt werden.
Hierzu wird eine \acs{https}-Verbindung sowohl von \app zur Middleware als auch von der Middleware zu CareNet verwendet.
\textcolor{red}{[https erklären mit security Buch]}.

\section{Einbinden von Plug-Ins in die Basisanwendung}

Wie in Kapitel \ref{sec:entwurfsentscheidungen} beschrieben, wird \app auf Basis einer Plug-In-Architektur entwickelt.
Die eigentliche Funktionalität, um die Anwendung produktiv einsetzen zu können, soll ausschließlich über Plug-Ins
hinzugefügt werden. Diese sind prinzipiell gekapselte Programmstücke, die bestimmte Funktionen bereitstellen. Plug-Ins
sollen der Basisanwendung leicht hinzugefügt und wieder entfernt werden können.\\
Plug-Ins werden in \app in Form eines Ordners zum Zeitpunkt der Entwicklung eingebunden, bevor die Anwendung zur
Installation auf dem Tablet-PC generiert wird. Ein Einbinden von Plug-Ins zur Laufzeit ist somit nicht möglich. Um eine
unbegrenzte Anzahl Plug-Ins über ein generisches Verfahren einbinden zu können, muss eine einheitliche Struktur gegeben
sein.  Abbildung \ref{fig:plugin} zeigt die Struktur eines Plug-Ins. Es besteht aus einer Menge von Dateien, die in
einem Ordner zusammengefasst werden. Der Ordner muss den Namen des Plug-Ins tragen und die darin enthaltenen Dateien
müssen der Namenskonventionen folgen, dass sie jeweils den Namen des Plug-Ins enthalten und ein beschreibendes
Stichwort für den Inhalt der Datei. Zwar könnte auch schon die Dateiendung als Indikator für den Inhalt dienen, jedoch
wird es durch den beschreibenden Zusatz noch eindeutiger.\\
Jedes Plug-In muss die in Abbildung \ref{fig:gui} gezeigte Struktur der Anwendung nutzen und die einzelnen Div-Elemente
über die in Variablen abgelegten \acs{id}s ansteuern. Um nicht bei jeder Veränderung eine neue HTML-Datei laden zu
müssen, wird der Inhalt der Div-Elemente dynamisch angepasst. Hierzu ist JavaScript notwendig, folglich muss ein Plug-In
eine JavaScript-Datei enthalten (\textit{Plug-In-Name.js}), die sowohl die Methoden zum Aufbau der grafischen
Oberfläche als auch die Anwendungslogik enthält. Wichtig für die grafische Darstellung von \acs{html}-Elementen sind
\ac{css}. Sie wird dazu verwendet, wiederverwendbare Formatierungen zu hinterlegen, die den \acs{html}-Elementen
zugewiesen werden können. Diese müssen, wie JavaScript auch, in einer separaten Datei zusammengefasst werden
(\textit{Plug-In-Name\_style.css}).\\
Die Basisanwendung soll keinerlei Abhängigkeiten zu den Plug-Ins haben, jedoch verwenden Plug-Ins von der Basisanwendung
bereitgestellte Methoden. Außerdem können Abhängigkeiten der Plug-Ins untereinander bestehen. Sind notwendige Methoden
nicht verfügbar oder wurden diese verändert (beispielsweise die Methodensignatur), kann dies dazu führen, dass ein
Plug-In nicht mehr funktioniert. Um die fehlenden Abhängigkeiten nicht erst zu entdecken, während der Nutzer eine nicht
verfügbare Funktion versucht zu verwenden, müssen Abhängigkeiten in einer Konfigurationsdatei beschrieben werden. Die
Datei \textit{Plug-In-Name\_config.json} enthält eine Liste aller Plug-Ins sowie deren Versionsnummer, die ein
Plug-In benötigt, um grundsätzlich funktionieren zu können. Außerdem enthält die Datei die Versionsnummer des Plug-Ins
selbst, um eventuelle Änderungen anzuzeigen. Werden nun Plug-Ins beim Öffnen der Anwendung geladen, kann zunächst
überprüft werden, ob alle notwendigen Abhängigkeiten aufgelöst werden können. Ist dies nicht der Fall, wird ein Plug-In
nicht geladen und der Nutzer bekommt einen Hinweis angezeigt.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figures/PluginStrukturAmbuNetMobile.png}
	\caption{Struktur eines Plug-Ins in \app}
	\label{fig:plugin}
\end{figure}

\begin{itemize}
  \item Plug-Struktur:
	  \begin{itemize}
	    \item Plug-In = Menge von Dateien [CHECK]
	    \item Alle zugehörigen Dateien gekapselt in einem Ordner [CHECK]
	    \item Namenskonventionen wg. JS global
	    \item Konfiguration eingebundener Plug-Ins (JSON)
	    \item Icon
	    \item JS-Datei (Problem der dynamischen Einbingung)
	    \item CSS-Datei [CHECK]
	    \item Versionsnummer, Konfig-Datei (Abhängigkeiten inkl. Versionsnummern)
	    \item Konstruktor, Methode zur Initialisierung
	    \item Arbeit mir Containern für GUI
	    \item Beschreibung der Abhängigkeiten zu Bibliotheken wie jQuery, jQuery mobile, PhoneGap (Redundanzen vermeiden)
	    \item Grafik zu Plug-In-Strukur
	  \end{itemize}
  \item Namenskonventionen
  \item Vorgang des Einbindens
  \item Probleme, Erweiterungsmöglichkeiten
\end{itemize}

\section{Das Plug-In "`Kontakte"'}
Für alle Plug-Ins feste Beschreibungsstruktur:
\begin{itemize}
  \item Begründung für Plug-In (aus welchen Anforderungen geht Plug-In hervor)
  \item Aufbau/Navigationsstruktur
  \item Zentrale Frage, die beantwortet werden muss: Welche Funktionalität geht aus welcher
  Anforderung hervor?
\end{itemize}

\ldots

\section{Das Plug-In "`Touren"'}
\ldots